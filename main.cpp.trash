#include "include/glad/glad.h"
#include "glfw-3.4/include/GLFW/glfw3.h"
#include <iostream>
#include <vector>
#include <string>
#include <typeinfo>
#include <cxxabi.h>
#include <memory>
#include <boost/log/trivial.hpp>
#include <boost/log/core.hpp>
#include <boost/log/expressions.hpp>
#include <stb/stb_image.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>


namespace Global {
    static glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
    static glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
    static glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
    static float deltaTime = 0.0f;
    
    static bool firstMouse = true;
    static double lastX = 0.0f;
    static double lastY = 0.0f;
    static float yaw = -90.0f;
    static float pitch = 0.0f;

    static float fov = 45.0f;
}


// Callback supposed to get fed to functions.
namespace Callback {
    static void framebufferSizeCallback(GLFWwindow* window, int width, int height) {
        glViewport(0, 0, width, height);
    }

    static void mouseCallback(GLFWwindow* window, double xpos, double ypos) {
        if (Global::firstMouse) {
            Global::lastX = xpos;
            Global::lastY = ypos;
            Global::firstMouse = false;
        }
        float xoffset = xpos - Global::lastX;
        float yoffset = Global::lastY - ypos;
        Global::lastX = xpos;
        Global::lastY = ypos;
        
        float SENSITIVITY = 0.1f;
        xoffset *= SENSITIVITY;
        yoffset *= SENSITIVITY;

        Global::yaw += xoffset;
        Global::pitch += yoffset;

        if (Global::pitch > 89.0f)
            Global::pitch = 89.0f;
        if (Global::pitch < -89.0f)
            Global::pitch = -89.0f;

        glm::vec3 direction;
        direction.x = cos(glm::radians(Global::yaw) * cos(glm::radians(Global::pitch)));
        direction.y = sin(glm::radians(Global::pitch));
        direction.z = sin(glm::radians(Global::yaw) * cos(glm::radians(Global::pitch)));
        Global::cameraFront = glm::normalize(direction);
    }

    static void scrollCallback(GLFWwindow* window, double xoffset, double yoffset) {
        Global::fov -= (float)yoffset;
        if (Global::fov < 1.0f)
            Global::fov = 1.0f;
        if (Global::fov > 45.0f)
            Global::fov = 45.0f;
    }
}


// EventHandle supposed to get called in gameLoop.
namespace EventHandle {
    static inline void processInput(GLFWwindow* window) {
        const float cameraSpeed = 2.5f * Global::deltaTime;
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            Global::cameraPos += cameraSpeed * Global::cameraFront;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            Global::cameraPos -= cameraSpeed * Global::cameraFront;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            Global::cameraPos -= cameraSpeed * glm::normalize(glm::cross(Global::cameraFront, Global::cameraUp));
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            Global::cameraPos += cameraSpeed * glm::normalize(glm::cross(Global::cameraFront, Global::cameraUp));
    }
}


// To bag GL related portions.
namespace GL {
    static inline void hint() {
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    }

    static inline void init(GLFWwindow* window) {
        ;
    }

    static inline void close(void) {
        ;
    }

    static inline void clearBlack(void) {
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
}


// To bag Window related portions.
namespace Window {
    GLFWwindow* window;
    int width;
    int height;
    float currentFrame;
    float lastFrame;

    static inline void init(int w, int h) {
        width = w;
        height = h;
        currentFrame = lastFrame = (float)glfwGetTime();
        Global::lastX = width / 2.0f;
        Global::lastY = height / 2.0f;

        glfwInit();
        GL::hint();
        window = glfwCreateWindow(width, height, "", NULL, NULL);
        glfwMakeContextCurrent(window);
        gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
        glViewport(0, 0, width, height);
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        glfwSetFramebufferSizeCallback(window, Callback::framebufferSizeCallback);
        glfwSetCursorPosCallback(window, Callback::mouseCallback);
        glfwSetScrollCallback(window, Callback::scrollCallback);
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);


        int nrAttributes;
        glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
        BOOST_LOG_TRIVIAL(info) << "INFO: Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;

    }

    static inline void close(void) {
        glfwDestroyWindow(window);
        glfwTerminate();
    }

    static inline bool shouldClose(void) {
        currentFrame = (float)glfwGetTime();
        Global::deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;
        return glfwWindowShouldClose(window);
    }
}


// collections of Objects
namespace ObjectFactory {


    class Object {
    public:
        std::vector<float> vertices;
        std::vector<GLuint> indices;
        std::vector<GLuint> texture;
        GLuint vao, vbo, ebo, program;

        Object() = default;

        ~Object() {
            if (program) glDeleteProgram(program);
            if (vbo) glDeleteBuffers(1, &vbo);
            if (ebo) glDeleteBuffers(1, &ebo);
            if (vao) glDeleteVertexArrays(1, &vao);
            for (GLuint texId : texture) {
                if (texId)
                    glDeleteTextures(1, &texId);
            }
        }

        std::string getClassname() {
            const char* classname_original = typeid(*this).name();
            int status = 0;
            std::unique_ptr<char, void(*)(void*)> res{
                abi::__cxa_demangle(classname_original, nullptr, nullptr, &status),
                std::free
            };
            return (status == 0) ? res.get() : std::string(classname_original);
        }

        virtual void draw() {}

        protected:
        int width, height;

        void setShader(const char* vertexShaderSrc, const char* fragmentShaderSrc, std::string classname) {
            std::cout << "INFO: setting shader for : " << classname << std::endl;
            GLuint vertexShader, fragmentShader;
            vertexShader = glCreateShader(GL_VERTEX_SHADER);
            fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
            glShaderSource(vertexShader, 1, &vertexShaderSrc, NULL);
            glShaderSource(fragmentShader, 1, &fragmentShaderSrc, NULL);
            glCompileShader(vertexShader);
            glCompileShader(fragmentShader);
            checkCompileFailure(vertexShader, "vertexShader");
            checkCompileFailure(fragmentShader, "fragmentShader");
            program = glCreateProgram();
            glAttachShader(program, vertexShader);
            glAttachShader(program, fragmentShader);
            glLinkProgram(program);
            checkCompileFailure(program, "program");
            glDeleteShader(vertexShader);
            glDeleteShader(fragmentShader);
        }

        void loadTexture(GLuint serialNo, const char* texImage, const char* texGLSLName) {
            if (texture.size() <= serialNo) texture.resize(serialNo + 1);
            glGenTextures(1, &texture[serialNo]);
            glActiveTexture(GL_TEXTURE0 + serialNo);
            glBindTexture(GL_TEXTURE_2D, texture[serialNo]);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            int width, height, nrChannels;
            stbi_set_flip_vertically_on_load(true);
            unsigned char* data = stbi_load(texImage, &width, &height, &nrChannels, 0);
            BOOST_LOG_TRIVIAL(info) << "texImage (width, height, channels) : " << texImage << " (" << width << ", "<< height << ", " << nrChannels << ")" << std::endl;
            if (data) {
                GLenum format = GL_RGB;
                if (nrChannels == 1)
                    format = GL_RED;
                else if (nrChannels == 3)
                    format = GL_RGB;
                else if (nrChannels == 4)
                    format = GL_RGBA;
                glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
                glGenerateMipmap(GL_TEXTURE_2D);
            } else {
                std::cout << "INFO: Failed to load texture image : " << texImage << std::endl;
            }
            glBindTexture(GL_TEXTURE_2D, 0);
            stbi_image_free(data);
        }

        int getLoc(const char* varName) {
            return glGetUniformLocation(program, varName);
        }

        void updateWidthHeight() {
            glfwGetFramebufferSize(Window::window, &width, &height);
        }
        private:
        void checkCompileFailure(GLuint id, std::string type) {
            int success;
            char infoLog[1024];
            if (type == "program") {
                glGetProgramiv(id, GL_LINK_STATUS, &success);
                if (!success) {
                    glGetProgramInfoLog(id, sizeof infoLog, NULL, infoLog);
                    std::cout << "ERROR::PROGRAM_LINKING_ERROR\n" << infoLog << std::endl;
                    exit(0);
                }
            } else {
                glGetShaderiv(id, GL_COMPILE_STATUS, &success);
                if (!success) {
                    glGetShaderInfoLog(id, sizeof infoLog, NULL, infoLog);
                    std::cout << "ERROR::SHADER_LINKING_ERROR of type: " << type << "\n" << infoLog << std::endl;
                    exit(0);
                }
            }
        }
    };


    class Quad : public Object {
        public:
        Quad() {
            vertices = {
                0.5f, 0.5f, 0.0f, // top right
                0.5f, -0.5f, 0.0f, // bottom right
                -0.5f, -0.5f, 0.0f, // bottom left
                -0.5f, 0.5f, 0.0f, // top left
            };
            indices = {
                0, 1, 3, // first triangle
                1, 2, 3 // second triangle
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
void main() {
    gl_Position = vec4(aPos, 1.0);
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
void main() {
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glGenBuffers(1, &ebo);
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(int) * indices.size(), indices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
            glEnableVertexAttribArray(0);
            glBindVertexArray(0);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }

        void draw() override {
            glBindVertexArray(vao);
            glUseProgram(program);
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void*)0);
            glUseProgram(0);
            glBindVertexArray(0);
        }
    };


    class Triangle : public Object {
    public:
        Triangle() {
            vertices = {
                -0.5f, -0.5f, 0.0f,
                0.5f, -0.5f, 0.0f,
                0.0f, 0.5f, 0.0f
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
void main() {
    gl_Position = vec4(aPos, 1.0);
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
void main() {
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
            glEnableVertexAttribArray(0);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }

        void draw() override {
            glBindVertexArray(vao);
            glUseProgram(program);
            glDrawArrays(GL_TRIANGLES, 0, 3);
            glUseProgram(0);
            glBindVertexArray(0);
        }
    };


    class TriangleColored : public Object {
    public:
        TriangleColored() {
            vertices = {
                // positions        colors
                -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f,
                0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,
                0.0f, 0.5f, 0.0f,   0.0f, 0.0f, 1.0f
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
out vec3 ourColor;
void main() {
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec3 ourColor;
void main() {
    FragColor = vec4(ourColor, 1.0f);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }

        void draw() override {
            glBindVertexArray(vao);
            glUseProgram(program);
            glDrawArrays(GL_TRIANGLES, 0, 3);
            glUseProgram(0);
            glBindVertexArray(0);
        }
    };


    class QuadTextured : public Object {
        public:
        QuadTextured() {
            vertices = {
                // postitions       colors            texture coords
                0.5f, 0.5f, 0.0f,   1.0f, 0.0f, 0.0f, 1.0f, 1.0f,    // top right
                0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f, 1.0f, 0.0f,    // bottom right
                -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,    // bottom left
                -0.5f, 0.5f, 0.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f     // top left
            };
            indices = {
                0, 1, 3, // first triangle
                1, 2, 3 // second triangle
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;
out vec3 ourColor;
out vec2 TexCoord;
void main() {
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec3 ourColor;
in vec2 TexCoord;
uniform sampler2D ourTexture;
void main() {
    FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0f);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glGenBuffers(1, &ebo);
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(int) * indices.size(), indices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
            glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glEnableVertexAttribArray(2);
            glBindVertexArray(0);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "ourTexture");
        }

        void draw() override {
            int textureSize = texture.size();
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glBindVertexArray(vao);
            glUseProgram(program);
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void*)0);
            glUseProgram(0);
            glBindVertexArray(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }
    };


    class QuadTexturedOverlap : public Object {
        public:
        QuadTexturedOverlap() {
            vertices = {
                // postitions       colors            texture coords
                0.5f, 0.5f, 0.0f,   1.0f, 0.0f, 0.0f, 1.0f, 1.0f,    // top right
                0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f, 1.0f, 0.0f,    // bottom right
                -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,    // bottom left
                -0.5f, 0.5f, 0.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f     // top left
            };
            indices = {
                0, 1, 3, // first triangle
                1, 2, 3 // second triangle
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;
out vec3 ourColor;
out vec2 TexCoord;
void main() {
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec3 ourColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2) * vec4(ourColor, 1.0f);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glGenBuffers(1, &ebo);
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(int) * indices.size(), indices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
            glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glEnableVertexAttribArray(2);
            glBindVertexArray(0);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "texture1");
            loadTexture(1, "awesomeface.png", "texture2");
        }

        void draw() override {
            int textureSize = texture.size();
            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glBindVertexArray(vao);
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void*)0);
            glUseProgram(0);
            glBindVertexArray(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }
    };


    class QuadTexturedOverlapRotating : public Object {
        public:
        QuadTexturedOverlapRotating() {
            vertices = {
                // postitions       colors            texture coords
                0.5f, 0.5f, 0.0f,   1.0f, 0.0f, 0.0f, 1.0f, 1.0f,    // top right
                0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f, 1.0f, 0.0f,    // bottom right
                -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,    // bottom left
                -0.5f, 0.5f, 0.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f     // top left
            };
            indices = {
                0, 1, 3, // first triangle
                1, 2, 3 // second triangle
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;
out vec3 ourColor;
out vec2 TexCoord;
uniform mat4 transform;
void main() {
    gl_Position = transform * vec4(aPos, 1.0);
    ourColor = aColor;
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec3 ourColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2) * vec4(ourColor, 1.0f);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glGenBuffers(1, &ebo);
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(int) * indices.size(), indices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
            glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glEnableVertexAttribArray(2);
            glBindVertexArray(0);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "texture1");
            loadTexture(1, "awesomeface.png", "texture2");
        }

        void draw() override {
            int textureSize = texture.size();
            glm::mat4 trans = glm::mat4(1.0f);
            trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
            // trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
            trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
            trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));

            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glUniformMatrix4fv(getLoc("transform"), 1, GL_FALSE, glm::value_ptr(trans));
            glBindVertexArray(vao);
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void*)0);
            glUseProgram(0);
            glBindVertexArray(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }
    };


    class Cube : public Object {
        public:
        Cube() {
            vertices = {
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
out vec2 TexCoord;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "texture1");
            loadTexture(1, "awesomeface.png", "texture2");
        }

        void draw() override {
            updateWidthHeight();
            int textureSize = texture.size();
            glm::mat4 model = glm::mat4(1.0f);
            glm::mat4 view = glm::mat4(1.0f);
            glm::mat4 projection = glm::mat4(1.0f);

            model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(0.5f, 1.0f, 0.0f));
            view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
            projection = glm::perspective(glm::radians(45.0f), width / (float)height, 0.1f, 100.0f);

            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glUniformMatrix4fv(getLoc("model"), 1, GL_FALSE, glm::value_ptr(model));
            glUniformMatrix4fv(getLoc("view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(getLoc("projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glBindVertexArray(vao);
            glDrawArrays(GL_TRIANGLES, 0, 36);
            glBindVertexArray(0);
            glUseProgram(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }
    };


    class Cubes : public Object {
        public:
        Cubes() {
            vertices = {
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
            };
            cubePositions = {
                glm::vec3( 0.0f,  0.0f,  0.0f),
                glm::vec3( 2.0f,  5.0f, -15.0f),
                glm::vec3(-1.5f, -2.2f, -2.5f),
                glm::vec3(-3.8f, -2.0f, -12.3f),
                glm::vec3( 2.4f, -0.4f, -3.5f),
                glm::vec3(-1.7f,  3.0f, -7.5f),
                glm::vec3( 1.3f, -2.0f, -2.5f),
                glm::vec3( 1.5f,  2.0f, -2.5f),
                glm::vec3( 1.5f,  0.2f, -1.5f),
                glm::vec3(-1.3f,  1.0f, -1.5f)
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
out vec2 TexCoord;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "texture1");
            loadTexture(1, "awesomeface.png", "texture2");
        }

        void draw() override {
            updateWidthHeight();
            int textureSize = texture.size();
            int cubePositionsSize = cubePositions.size();
            glm::mat4 model = glm::mat4(1.0f);
            glm::mat4 view = glm::mat4(1.0f);
            glm::mat4 projection = glm::mat4(1.0f);

            // model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(0.5f, 1.0f, 0.0f));
            view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
            projection = glm::perspective(glm::radians(45.0f), width / (float)height, 0.1f, 100.0f);

            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glBindVertexArray(vao);
            glUniformMatrix4fv(getLoc("view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(getLoc("projection"), 1, GL_FALSE, glm::value_ptr(projection));
            for (int i = 0; i < cubePositionsSize; ++i) {
                model = glm::translate(model, cubePositions[i]);
                // float angle = glfwGetTime();
                float angle = 20.0f * i;
                model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
                glUniformMatrix4fv(getLoc("model"), 1, GL_FALSE, glm::value_ptr(model));
                glDrawArrays(GL_TRIANGLES, 0, 36);
            }
            glBindVertexArray(0);
            glUseProgram(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }

        private:
        std::vector<glm::vec3> cubePositions;
    };


    class CubesWithLookAt : public Object {
        public:
        CubesWithLookAt() {
            vertices = {
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
            };
            cubePositions = {
                glm::vec3( 0.0f,  0.0f,  0.0f),
                glm::vec3( 2.0f,  5.0f, -15.0f),
                glm::vec3(-1.5f, -2.2f, -2.5f),
                glm::vec3(-3.8f, -2.0f, -12.3f),
                glm::vec3( 2.4f, -0.4f, -3.5f),
                glm::vec3(-1.7f,  3.0f, -7.5f),
                glm::vec3( 1.3f, -2.0f, -2.5f),
                glm::vec3( 1.5f,  2.0f, -2.5f),
                glm::vec3( 1.5f,  0.2f, -1.5f),
                glm::vec3(-1.3f,  1.0f, -1.5f)
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
out vec2 TexCoord;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "texture1");
            loadTexture(1, "awesomeface.png", "texture2");
        }

        void draw() override {
            updateWidthHeight();
            int textureSize = texture.size();
            int cubePositionsSize = cubePositions.size();
            glm::mat4 model = glm::mat4(1.0f);
            glm::mat4 view = glm::mat4(1.0f);
            glm::mat4 projection = glm::mat4(1.0f);

            projection = glm::perspective(glm::radians(45.0f), width / (float)height, 0.1f, 100.0f);
            
            const float radius = 10.0f;
            float camX = sin(glfwGetTime()) * radius;
            float camZ = cos(glfwGetTime()) * radius;
            view = glm::lookAt(glm::vec3(camX, 0.0f, camZ), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));

            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glBindVertexArray(vao);
            glUniformMatrix4fv(getLoc("view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(getLoc("projection"), 1, GL_FALSE, glm::value_ptr(projection));
            for (int i = 0; i < cubePositionsSize; ++i) {
                model = glm::translate(model, cubePositions[i]);
                // float angle = glfwGetTime();
                float angle = 20.0f * i;
                model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
                glUniformMatrix4fv(getLoc("model"), 1, GL_FALSE, glm::value_ptr(model));
                glDrawArrays(GL_TRIANGLES, 0, 36);
            }
            glBindVertexArray(0);
            glUseProgram(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }

        private:
        std::vector<glm::vec3> cubePositions;
    };


    class CubesWithCamera : public Object {
        public:
        CubesWithCamera() {
            vertices = {
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
            };
            cubePositions = {
                glm::vec3( 0.0f,  0.0f,  0.0f),
                glm::vec3( 2.0f,  5.0f, -15.0f),
                glm::vec3(-1.5f, -2.2f, -2.5f),
                glm::vec3(-3.8f, -2.0f, -12.3f),
                glm::vec3( 2.4f, -0.4f, -3.5f),
                glm::vec3(-1.7f,  3.0f, -7.5f),
                glm::vec3( 1.3f, -2.0f, -2.5f),
                glm::vec3( 1.5f,  2.0f, -2.5f),
                glm::vec3( 1.5f,  0.2f, -1.5f),
                glm::vec3(-1.3f,  1.0f, -1.5f)
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
out vec2 TexCoord;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            loadTexture(0, "container.jpg", "texture1");
            loadTexture(1, "awesomeface.png", "texture2");
        }

        void draw() override {
            updateWidthHeight();
            float aspectRatio = width / (float)height;
            int textureSize = texture.size();
            int cubePositionsSize = cubePositions.size();
            glm::mat4 model = glm::mat4(1.0f);
            glm::mat4 view = glm::mat4(1.0f);
            glm::mat4 projection = glm::mat4(1.0f);

            projection = glm::perspective(glm::radians(Global::fov), aspectRatio, 0.1f,100.0f);

            view = glm::lookAt(Global::cameraPos, Global::cameraPos + Global::cameraFront, Global::cameraUp);

            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glBindVertexArray(vao);
            glUniformMatrix4fv(getLoc("view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(getLoc("projection"), 1, GL_FALSE, glm::value_ptr(projection));
            for (int i = 0; i < cubePositionsSize; ++i) {
                model = glm::translate(model, cubePositions[i]);
                // float angle = glfwGetTime();
                float angle = 20.0f * i;
                model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
                glUniformMatrix4fv(getLoc("model"), 1, GL_FALSE, glm::value_ptr(model));
                glDrawArrays(GL_TRIANGLES, 0, 36);
            }
            glBindVertexArray(0);
            glUseProgram(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }

        private:
        std::vector<glm::vec3> cubePositions;
    };


    class CubeColors : public Object {
        public:
        CubeColors() {
            vertices = {
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
                0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
                0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
                -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
                -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
            };
            cubePositions = {
                glm::vec3( 0.0f,  0.0f,  0.0f),
                glm::vec3( 2.0f,  5.0f, -15.0f),
                glm::vec3(-1.5f, -2.2f, -2.5f),
                glm::vec3(-3.8f, -2.0f, -12.3f),
                glm::vec3( 2.4f, -0.4f, -3.5f),
                glm::vec3(-1.7f,  3.0f, -7.5f),
                glm::vec3( 1.3f, -2.0f, -2.5f),
                glm::vec3( 1.5f,  2.0f, -2.5f),
                glm::vec3( 1.5f,  0.2f, -1.5f),
                glm::vec3(-1.3f,  1.0f, -1.5f)
            };
            const char* vertexShaderSrc =
R"(
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
out vec2 TexCoord;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
)";
            const char* fragmentShaderSrc =
R"(
#version 460 core
out vec4 FragColor;
in vec2 TexCoord;
uniform sampler2D texture1;
uniform sampler2D texture2;
void main() {
    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);
}
)";
            setShader(vertexShaderSrc, fragmentShaderSrc, getClassname());
            glGenVertexArrays(1, &(vao));
            glGenBuffers(1, &(vbo));
            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER, vbo);
            glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glBindVertexArray(0);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }

        void draw() override {
            updateWidthHeight();
            float aspectRatio = width / (float)height;
            int textureSize = texture.size();
            int cubePositionsSize = cubePositions.size();
            glm::mat4 model = glm::mat4(1.0f);
            glm::mat4 view = glm::mat4(1.0f);
            glm::mat4 projection = glm::mat4(1.0f);

            projection = glm::perspective(glm::radians(Global::fov), aspectRatio, 0.1f,100.0f);

            view = glm::lookAt(Global::cameraPos, Global::cameraPos + Global::cameraFront, Global::cameraUp);

            glUseProgram(program);
            for (int i = 0; i < textureSize; ++i) {
                glActiveTexture(GL_TEXTURE0 + i);
                glBindTexture(GL_TEXTURE_2D, texture[i]);
            }
            glUniform1i(getLoc("texture1"), 0);
            glUniform1i(getLoc("texture2"), 1);
            glBindVertexArray(vao);
            glUniformMatrix4fv(getLoc("view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(getLoc("projection"), 1, GL_FALSE, glm::value_ptr(projection));
            for (int i = 0; i < cubePositionsSize; ++i) {
                model = glm::translate(model, cubePositions[i]);
                // float angle = glfwGetTime();
                float angle = 20.0f * i;
                model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f));
                glUniformMatrix4fv(getLoc("model"), 1, GL_FALSE, glm::value_ptr(model));
                glDrawArrays(GL_TRIANGLES, 0, 36);
            }
            glBindVertexArray(0);
            glUseProgram(0);
            for (int i = 0; i < textureSize; ++i) {
                glBindTexture(GL_TEXTURE_2D, 0);
            }
        }

        private:
        std::vector<glm::vec3> cubePositions;
    };
}


// Main body of the Application.
namespace App {
    static void run(void) {
        Window::init(800, 600);
        {
            auto obj = ObjectFactory::CubesWithCamera();
            while (!Window::shouldClose()) {
                glfwPollEvents();
                EventHandle::processInput(Window::window);
                GL::clearBlack();
                obj.draw();
                glfwSwapBuffers(Window::window);
            }
        }
        Window::close();
    }
}


int main(void) {
    App::run();
}